input {
	beats {
		port => 5044
	}
}

filter {
  #---OLD PARSER---
  # Extract the fields from the 'message' field using Grok
  #grok {
    #match => { "message" => "%{WORD:log_level}:%{WORD:logger}:%{IP:client_ip} - - \[%{NUMBER:day}/%{WORD:month}/%{NUMBER:year} %{TIME:time}\] \"%{WORD:http_method} %{URIPATHPARAM:path} HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code}(?: -)?" }
  #}

  # //INFO:werkzeug:172.22.0.3 - - [26/Mar/2025 19:35:48] "GET /public?p=45 HTTP/1.1" 200 -

  #---NEW PARSER---
  grok {
    match => { "message" => '%{DATE_EU:date} %{TIME:time}" level=%{WORD:level} IP="%{IP:IP}" logger=%{WORD:logger} method=%{WORD:method} path=/%{WORD:path} responseCode=%{NUMBER:responseCode}' }

    #Message:
    # time="2025-03-27 11:07:48" level=info IP=172.23.0.1 logger=logrus method=GET path=/latest responseCode=200
  }


  # Check if the grok filter successfully matched
  if "_grokparsefailure" not in [tags] {
    # Optional: You can mutate to add more tags or perform other actions here if needed.
    mutate {
      add_field => {
        "extracted_message" => "Method: %{http_method}, Path: %{path}, Response: %{response_code}"
      }
    }
  } else {
    # If Grok parsing failed, add a tag to notify for debugging
    mutate {
      add_tag => ["_grokparsefailure"]
    }
  }
}


output {
	elasticsearch {
		hosts => "elasticsearch:9200"
		user => "logstash_internal"
		password => "${LOGSTASH_INTERNAL_PASSWORD}"
	}
}